/*
=============================================================================
Title : main.cpp
Description : This program simulates an elevator operating system. It
              communicates with a Flask API written by Dr. Eric Rees to read
              in data and process it according to a ******* algorithm to
              efficiently run the elevator system
Author : Jaden Hicks & Josh Josey
Date : 05/04/2025
Version : 1.0
Usage : Compile and run this program using the GNU C++ compiler
Notes : -   This program requires that the API is running on the port provided
            as a command line argument
        -   Must be compiled with the -pthread -lcurl flags
C++ Version : 11 or higher
=============================================================================
*/
#include <iostream>
#include <fstream>
#include <vector>

#include <chrono>
#include <thread>
#include <atomic>
#include <curl/curl.h>
#include <chrono>
#include <deque>

#include "building.h"
#include "api_control.h"
// #include "queue.h"

//Function Prototypes
void *inputThread(void *);
void *schedulerThread(void *);
void *outputThread(void *);

//Global Varibales
std::string host;
Building building;
std::deque<Person> people_q;
std::deque<Assignment> assignment_q;
//Synchonization Variables
std::atomic<bool> sim_complete_flag(false);

int main(int argc, char *argv[]) {
    if (argc != 3) {
        std::cerr << "ERROR: Not enough arguments\nUsage: " << argv[0] << " <path to input file> <port>" << std::endl;
        return 1;
    }

    // -- Following was adapted from GitHub Copilot --

    std::ifstream inp(argv[1]);
    if (!inp.is_open()) {
        std::cerr << "Could not open file: " << argv[1] << std::endl;
        return 1;
    }

    building = setupBuilding(inp);
    if (building.numElevators() == 0) {
        std::cerr << "Building setup failed." << std::endl;
        return 1;
    }
    inp.close();

    std::cout << "Building has " << building.numElevators() << " elevators." << std::endl;
    for (int i = 0; i < building.numElevators(); i++) {
        building.elevators[i].print();
    }
    // -- End of GitHub Copilot adaptation -- (this comment was generated by Copilot haha)

    
    std::cout << "Starting Elevator OS..." << std::endl;
    std::string port = argv[2];
    host = "http://localhost:" + port;
    std::cout << "Host: " << host << std::endl;
    //initialize curl
    curl_global_init(CURL_GLOBAL_ALL);

    //ensure the api is running
	simStatus(host);
	simulationControl(host,"start");
    if (simStatus(host) < 2) {
        std::cerr << "Simulation failed to start." << std::endl;
        exit(1);
    };

    // TESTS
	//check the status of an elevator
    for (int i=0; i<building.numElevators(); i++)
        elevatorStatus(host, building.elevators[i].getName());
    //see if you can get the next person
    Person test(nextInput(host));
    test.print();
    //see if you can add someone to an elevator
    addToElevator(host, test.getId(), building.elevators[0].getName());
    std::this_thread::sleep_for(std::chrono::seconds(2));
	//check the status of an elevator
    for (int i=0; i<building.numElevators(); i++)
        elevatorStatus(host, building.elevators[i].getName());
    
    //start input thread
    inputThread(NULL);

    //ensure the API stopped
	simStatus(host);
	simulationControl(host,"stop");
	simStatus(host);

	//cleanup curl
    curl_global_cleanup();
    return 0;
}


void *inputThread(void *arg){
    int status = simStatus(host);
    while(true){
        //Get the next person waiting
        Person next = nextInput(host);
        //if there is no one waiting to be added then sleep
        if (next.getId() != "NONE") {
            //DEBUGnext.print();
            people_q.push_back(next);
        } else {
            //check if the simulation is complete
            status = simStatus(host);

            if(status == 3){
                sim_complete_flag.store(true);
                return NULL;
            }
            //DEBUGstd::cout << "INPUT: Nobody waiting to board an elevator, going to sleep" << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
}

void *schedulerThread(void *arg) {
    return NULL;
}

void *outputThread(void *arg) {
    return NULL;
}