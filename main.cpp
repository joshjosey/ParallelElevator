/*
=============================================================================
Title : main.cpp
Description : This program simulates an elevator operating system. It
              communicates with a Flask API written by Dr. Eric Rees to read
              in data and process it according to a ******* algorithm to
              efficiently run the elevator system
Author : Jaden Hicks & Josh Josey
Date : 05/04/2025
Version : 1.0
Usage : Compile and run this program using the GNU C++ compiler
Notes : -   This program requires that the API is running on the port provided
            as a command line argument
        -   Must be compiled with the -pthread -lcurl flags
C++ Version : 11 or higher
=============================================================================
*/
#include <iostream>
#include <fstream>
#include <vector>

#include <chrono>
#include <thread>
#include <atomic>
#include <curl/curl.h>
#include <chrono>
#include <deque>

#include "building.h"
#include "api_control.h"
// #include "queue.h"

//Function Prototypes
void inputThread();
void schedulerThread();
void outputThread();
bool inRange(Elevator, Person);

//Global Variables
std::string host;
Building building;
std::deque<Person> people_q;
std::deque<std::pair<std::string,std::string>> output_q; //always push as (person_id, elevator_id)

//Synchonization Variables
std::atomic<bool> sim_complete_flag(false);

int main(int argc, char *argv[]) {
    if (argc != 3) {
        std::cerr << "ERROR: Not enough arguments\nUsage: " << argv[0] << " <path to input file> <port>" << std::endl;
        return 1;
    }

    // -- Following was adapted from GitHub Copilot --

    std::ifstream inp(argv[1]);
    if (!inp.is_open()) {
        std::cerr << "Could not open file: " << argv[1] << std::endl;
        return 1;
    }

    building = setupBuilding(inp);
    if (building.numElevators() == 0) {
        std::cerr << "Building setup failed." << std::endl;
        return 1;
    }
    inp.close();

    std::cout << "Building has " << building.numElevators() << " elevators." << std::endl;
    for (int i = 0; i < building.numElevators(); i++) {
        building.elevators[i].print();
    }
    // -- End of GitHub Copilot adaptation -- (this comment was generated by Copilot haha)

    
    std::cout << "Starting Elevator OS..." << std::endl;
    std::string port = argv[2];
    host = "http://localhost:" + port;
    std::cout << "Host: " << host << std::endl;
    //initialize curl
    curl_global_init(CURL_GLOBAL_ALL);

    //ensure the api is running
	simStatus(host);
	simulationControl(host,"start");
    if (simStatus(host) < 2) {
        std::cerr << "Simulation failed to start." << std::endl;
        exit(1);
    };

    // // TESTS
	// //check the status of an elevator
    // for (int i=0; i<building.numElevators(); i++)
    //     elevatorStatus(host, building.elevators[i].getName());
    // //see if you can get the next person
    // Person test(nextInput(host));
    // test.print();
    // //see if you can add someone to an elevator
    // addToElevator(host, test.getId(), building.elevators[0].getName());
    // std::this_thread::sleep_for(std::chrono::seconds(2));
	// //check the status of an elevator
    // for (int i=0; i<building.numElevators(); i++)
    //     elevatorStatus(host, building.elevators[i].getName());
    
    //start input thread
    inputThread();

    //ensure the API stopped
	simStatus(host);
	simulationControl(host,"stop");
	simStatus(host);

	//cleanup curl
    curl_global_cleanup();
    return 0;
}


void inputThread(){
    int status = simStatus(host);
    while(true){
        for (auto &e : building.elevators) {
            std::string status = elevatorStatus(host, e.getName());
            e.updateStatus(status);
            e.print();
        }
        //Get the next person waiting
        Person next = nextInput(host);
        //if there is no one waiting to be added then sleep
        if (next.getId() != "NONE") {
            //DEBUGnext.print();
            people_q.push_back(next);
        } else {
            //check if the simulation is complete
            status = simStatus(host);

            if(status == 3){
                sim_complete_flag.store(true);
                return;
            }
            //DEBUGstd::cout << "INPUT: Nobody waiting to board an elevator, going to sleep" << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
}

void schedulerThread() {
    while(true){
        //Update the elevator status before assignment
        for(auto& e : building.elevators){
            std::string status = elevatorStatus(host, e.getName());
            e.updateStatus(status);
        }
        //WHILE PERSON QUEUE IS NOT EMPTY
        {
            Person p;
            //Check each elevator to find the best one
            for(int i = 0; i < building.numElevators(); i++){
                int min = 0;
                std::string status = elevatorStatus(host, building.elevators[i].getName());
                building.elevators[i].updateStatus(status);

                //check if it is in range and has capactiy
                if( !building.elevators[i].inRange(p.getStart(), p.getEnd()) || (building.elevators[i].getRemainingCapacity() == 0) ){
                    continue;
                }
                //Calculate that elevators score
                
            }
            //Enqueue the best elevator OR requeue the person
            //decrement rem cap
        }
        //SIGNAL THE OTHER THREADS AND GO TO SLEEP
        if(sim_complete_flag.load() == true ){
            return;
        }
    }
}

void outputThread() {
    while(true) {
        std::string p_id = output_q.front().first;
        std::string e_id = output_q.front().second;
        output_q.pop_front();
        
        addToElevator(host, p_id, e_id);

        if (sim_complete_flag.load() == true) {
            return;
        }
    }
}

