/*
=============================================================================
Title : main.cpp
Description : This program simulates an elevator operating system. It
              communicates with a Flask API written by Dr. Eric Rees to read
              in data and process it according to a ******* algorithm to
              efficiently run the elevator system
Author : Jaden Hicks & Josh Josey
Date : 05/04/2025
Version : 1.0
Usage : Compile and run this program using the GNU C++ compiler
Notes : -   This program requires that the API is running on the port provided
            as a command line argument
        -   Must be compiled with the -pthread -lcurl flags
C++ Version : 11 or higher
=============================================================================
*/
//test
#include <iostream>
#include <fstream>
#include <vector>

#include <chrono>
#include <thread>
#include <condition_variable>
#include <atomic>
#include <curl/curl.h>
#include <chrono>
#include <deque>

#include "building.h"
#include "api_control.h"
// #include "queue.h"

//Function Prototypes
void inputThread();
void schedulerThread();
void outputThread();
bool inRange(Elevator, Person);

//Global Variables
std::string host;
Building building;
std::deque<Person> people_q;
std::deque<std::pair<std::string,std::string>> output_q; //always push as (person_id, elevator_id)

//Synchonization Variables
std::atomic<bool> sim_complete_flag(false);
std::condition_variable io_cv;
std::condition_variable schedule_cv;
std::mutex mtx;

int main(int argc, char *argv[]) {
    if (argc != 3) {
        std::cerr << "ERROR: Not enough arguments\nUsage: " << argv[0] << " <path to input file> <port>" << std::endl;
        return 1;
    }

    // -- Following was adapted from GitHub Copilot --

    std::ifstream inp(argv[1]);
    if (!inp.is_open()) {
        std::cerr << "Could not open file: " << argv[1] << std::endl;
        return 1;
    }

    building = setupBuilding(inp);
    if (building.numElevators() == 0) {
        std::cerr << "Building setup failed." << std::endl;
        return 1;
    }
    inp.close();

    std::cout << "Building has " << building.numElevators() << " elevators." << std::endl;
    for (int i = 0; i < building.numElevators(); i++) {
        building.elevators[i].print();
    }
    // -- End of GitHub Copilot adaptation -- (this comment was generated by Copilot haha)

    
    std::cout << "Starting Elevator OS..." << std::endl;
    std::string port = argv[2];
    host = "http://localhost:" + port;
    std::cout << "Host: " << host << std::endl;
    //initialize curl
    curl_global_init(CURL_GLOBAL_ALL);

    //ensure the api is running
	simStatus(host);
	simulationControl(host,"start");
    if (simStatus(host) < 2) {
        std::cerr << "Simulation failed to start." << std::endl;
        exit(1);
    };

    // // TESTS
	// //check the status of an elevator
    // for (int i=0; i<building.numElevators(); i++)
    //     elevatorStatus(host, building.elevators[i].getName());
    // //see if you can get the next person
    // Person test(nextInput(host));
    // test.print();
    // //see if you can add someone to an elevator
    // addToElevator(host, test.getId(), building.elevators[0].getName());
    // std::this_thread::sleep_for(std::chrono::seconds(2));
	// //check the status of an elevator
    // for (int i=0; i<building.numElevators(); i++)
    //     elevatorStatus(host, building.elevators[i].getName());
    
    //start input thread
    std::thread inp_thread(inputThread);
    std::thread schedule_thread(schedulerThread);
    std::thread outp_thread(outputThread);
    inp_thread.join();
    schedule_thread.join();
    outp_thread.join();
    // ensure the API stopped
    simStatus(host);
	simulationControl(host,"stop");
	simStatus(host);

	//cleanup curl
    curl_global_cleanup();
    return 0;
}


void inputThread(){
    int status = simStatus(host);
    while(true){
        //Get the next person waiting
        Person next = nextInput(host);

        std::cout << "INPUT: updating elevators" << std::endl;
        for (auto &e : building.elevators)
        {
            std::string status = elevatorStatus(host, e.getName());
            std::cout << "\nINPUT: " << status << std::endl;
            e.updateStatus(status);
        }

        //Get people until nobody else is coming
        while(next.getId() != "NONE") {
            //DEBUGnext.print();
            std::cout << "\tINPUT: Adding " << next.getId() << " to the people q " << std::endl;
            people_q.push_back(next);
            next = nextInput(host);
        }

        //check if the simulation is complete
        status = simStatus(host);
        if(status == 3){
            std::cout << "INPUT: Simulation complete, terminating..." << std::endl;
            sim_complete_flag.store(true);
            schedule_cv.notify_one();
            return;
        }

        //If there is any data then wake the other threads then go to sleep, otherwise wait a second and retry
        if(!people_q.empty()){
            std::unique_lock<std::mutex> lock(mtx);
            std::cout << "INPUT: People waiting to board waking the scheduler, going to sleep..." << std::endl;
            schedule_cv.notify_one();
            io_cv.wait(lock, []()
                       { return people_q.empty()  || sim_complete_flag.load(); });
            std::cout << "INPUT: Checking for passengers" << std::endl;

        } else{
            std::cout << "\tINPUT: Nobody waiting to board an elevator, waiting to retry" << std::endl;
            std::this_thread::sleep_for(std::chrono::milliseconds(1000));
        }
    }
}

void schedulerThread() {
    while(true){
        //Wait for the other threads to be complete
        std::unique_lock<std::mutex> lock(mtx);
        std::cout << "SCHEDULER: Going to sleep..." << std::endl;
        io_cv.notify_all();
        schedule_cv.wait(lock, [](){ 
            return (!people_q.empty() && output_q.empty()) || sim_complete_flag.load(); 
        });

        std::cout << "SCHEDULER: updating elevators" << std::endl;
        for (auto &e : building.elevators)
        {
            std::string status = elevatorStatus(host, e.getName());
            std::cout << "\tSCHEDULER: " << status << std::endl;
            e.updateStatus(status);
        }
        std::cout << "SCHEDULER: updating elevators" << std::endl;

        //WHILE PERSON QUEUE IS NOT EMPTY
        while(!people_q.empty()){
            Person p(people_q.front());
            people_q.pop_front();
            int min = 9999;
            int min_idx = -1;
            // Update the elevator status before assignment
            std::cout << "SCHEDULER: comparing elevators for " << p.getId() << " (" << p.getStart() << " -> " << p.getEnd() << ") " << std::endl;
            for(int i = 0; i < building.numElevators(); i++){
                int score = 0;
                char dir_to_person = 'S';

                //check if it is in range and has capactiy
                if( !building.elevators[i].inRange(p.getStart(), p.getEnd()) ){
                    std::cout << "\tSCHEDULER: " << building.elevators[i].getName() << " cannot reach desired floor" << std::endl;
                    continue;
                }
                if( building.elevators[i].getRemainingCapacity() == 0){
                    std::cout << "\tSCHEDULER: " << building.elevators[i].getName() << " has no space" << std::endl;
                    continue;
                }

                //check the direction it must go to the person
                if(building.elevators[i].getCurrent() < p.getStart()){
                    dir_to_person = 'U';
                } else if(building.elevators[i].getCurrent() > p.getStart()) {
                    dir_to_person = 'D';
                }

                //if the elevator is stationary or going toward the person the add the current distance
                char elevator_dir = building.elevators[i].getDirection();
                if(elevator_dir == dir_to_person || elevator_dir == 'S')
                {
                    score += abs(building.elevators[i].getCurrent() - p.getStart());
                } 
                //otherwise add the maximum possible distance
                else 
                {
                    if(elevator_dir == 'U')
                    {
                        score += abs(building.elevators[i].getHighest() - building.elevators[i].getCurrent()) + 
                                 abs(building.elevators[i].getHighest() - p.getStart());
                    } 
                    else if (elevator_dir == 'D') 
                    {
                        score += abs(building.elevators[i].getLowest() - building.elevators[i].getCurrent()) + 
                                 abs(building.elevators[i].getLowest() - p.getStart());
                    }
                }

                //Increment the score for each passenger assigned to / on the elevator
                score += abs(building.elevators[i].getCapacity() - building.elevators[i].getRemainingCapacity())*2;

                //check if it has the lowest score
                if(score < min){
                    min = score;
                    min_idx = i;
                }
                std::cout << "\tSCHEDULER: " << building.elevators[i].getName() << " has a score of " << score << std::endl;
            }
            //Enqueue the best elevator OR requeue the person
            if(min_idx >= 0){
                output_q.emplace_back(p.getId(), building.elevators[min_idx].getName());
                // add person to elevator object
                building.elevators[min_idx].addPerson(p);
                //decrement the remaining capacity of the elevator
                building.elevators[min_idx].decrementRemainingCapacity();
                std::cout << "SCHEDULER: Queueing " << output_q.back().first << " ( " << p.getStart() << " -> " << p.getEnd() << ") " 
                                                    << " on elevator " << output_q.back().second << " ( " << building.elevators[min_idx].getCurrent() << " -> " << building.elevators[min_idx].getDirection() << ") "<< std::endl;
            }
            else
            {
                people_q.push_back(p);
                std::cout << "Could not find an elevator for " << p.getId() << " requeueing" << std::endl;

            }
        }
        //SIGNAL THE OTHER THREADS AND GO TO SLEEP
        if(sim_complete_flag.load() == true ){
            std::cout << "SCHEDULER: Simulation complete, terminating..." << std::endl;
            io_cv.notify_all();
            return;
        }
    }
}

void outputThread() {
    while(true) {
        while(!output_q.empty()){
            std::string p_id = output_q.front().first;
            std::string e_id = output_q.front().second;
            output_q.pop_front();

            std::cout << "OUTPUT: Placing " << p_id << " on elevator " << e_id << std::endl;
            addToElevator(host, p_id, e_id);
        }
        //check if the simulation is complete
        if (sim_complete_flag.load() == true) {
            std::cout << "OUTPUT: Simulation complete, terminating..." << std::endl;
            schedule_cv.notify_one();
            return;
        }
        //Wake the other threads then go to sleep
        {
            std::unique_lock<std::mutex> lock(mtx);
            std::cout << "OUTPUT: All passengers placed, going to sleep..." << std::endl;
            schedule_cv.notify_one();
            io_cv.wait(lock, [](){ return !output_q.empty() || sim_complete_flag.load(); });
        }
    }
}

